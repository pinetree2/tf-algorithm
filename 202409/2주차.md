https://www.acmicpc.net/problem/1806 - 부분합 G4
https://www.acmicpc.net/problem/2179 - 비슷한 단어 G4
https://www.acmicpc.net/problem/17135 - 캐슬디펜스 G3
https://www.acmicpc.net/problem/13905 - 세부 G4
https://www.acmicpc.net/problem/11568 - 민균's 계략 S2

SQL)
SUM - https://school.programmers.co.kr/learn/courses/30/lessons/131697

### SUM,MIN,MAX

---

<details>
  <summary>131797 </summary>
  
  ```
  SELECT MAX(PRICE) as 'MAX_PRICE' FROM PRODUCT
  ```
</details>


<details>
  <summary> 59406 </summary>
  ```
  -- 코드를 입력하세요
  SELECT COUNT(ANIMAL_ID) as 'count' FROM ANIMAL_INS
  ```

</details>

<details>
  <summary>293261</summary>

  개수세는건 COUNT

  - 293261

  물고기 종류 별로 가장 큰 물고기의 ID, 물고기 이름, 길이를 출력하는 SQL 문을 작성해주세요.

  물고기의 ID 컬럼명은 ID, 이름 컬럼명은 FISH_NAME, 길이 컬럼명은 LENGTH로 해주세요.
  결과는 물고기의 ID에 대해 오름차순 정렬해주세요.
  단, 물고기 종류별 가장 큰 물고기는 1마리만 있으며 10cm 이하의 물고기가 가장 큰 경우는 없습니다.

  다까먹었네
  오름차순 정리 -> ? 오더바이였나

  글구 조인 해야함 type 으로 이름 찾아야해서.. 

  내생각엔 개념한번 싹 보고 문제푸는게 훨 나을듯
  데베설 자료 가져와잇!
</details>

---
## 알고리즘 ( 백준 )

<details>
  <summary>민균이의 계략 11568</summary>
  - 증가하는 순서의 배열이 아니면 놀림받는대. 너무함
  - 카드가 5개면, 최대한 많은 원소의 개수를 가진 카드 배열을 제시해야함.

  테스트 케이스를 보며 이해해보자.<br>
  1,2,8,9,10 은 왜 안되지? 아 알겠다.
  이 순서를 바꿀 수는 없는것 같다. <br>
  예컨대 배열이 8 9 1 2 10 이면
  1 2 10이 되고, 8,9,10 은 되는데 1,2,8은 안된다. 왜냐면 8이 좀 더 앞순서에 제시되었으니까! <br>

  그리디 비스무리 한건가..?
  <br>
  
  **문제 풀이**

  - 반복문을 돌면서 원소 다음값이 크다면 원소의 개수 +1
  - 만약 작다면 반복문 종료, 다음원소부터 다시 반복문 돌기,
    - 이때 두번째 반복문과 이전에 돌았던 값의 answer 를 비교해본다. 더 큰값을 answer 로 넣어준다.
  
  - 지금 위 상황에 오류가 있다. 지금은 그냥 그 다음 원소가 큰지만 확인해서.. 잘못됨. 
  - 예컨대 8 > 9> 면 9보다 큰게 있는지를 찾아야함 
  그것도 추가해주자.
  <br>
  <br>
  <br>

  ```
  import sys
  N = int(sys.stdin.readline())
  card = list(map(int, sys.stdin.readline().split()))

  answer =0
  for i in range(0,N):
      compare_num = card[i]
      num =1
      for j in range(i+1,N):
          if compare_num < card[j]:
              num +=1

      answer = max(answer,num)

  print(answer)
```
이렇게 했는데 틀렸댄다. dp 를 하랜다.
이게 LIS(최장증가수열 알고리즘)이라고한다.


### LIS?
LIS 알고리즘 (Longest Increasing Subsequence Algorithm) 은 최장증가수열 알고리즘으로 증가하는 원소들의 가장 긴 부분집합을 찾는 알고리즘이다. <br>
<br>
[링크](<https://gom20.tistory.com/91#:~:text=LIS%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20(Longest%20Increasing%20Subsequence,%EC%A7%91%ED%95%A9%EC%9D%84%20%EC%B0%BE%EB%8A%94%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%8B%A4.>)보고 이해하기

  
</details>


<details>
  <summary>13905</summary>

  









</details>
<details>
  <summary>dd</summary>


</details>
<details>
  <summary>dd</summary>


</details>
<details>
  <summary>dd</summary>


</details>

---
### mst 공부하기 - union-find 예제 풀어보며 이해하기 
